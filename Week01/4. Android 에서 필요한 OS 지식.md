# Questions
## 1. 가상 메모리와 페이지 교체 알고리즘의 Android 활용 (Android에서 메모리 관리)
안드로이드의 ART와 DalvikVM 은 페이징과 메모리 매핑을 사용하여 메모리를 관리한다.

기존에 OS에서 공부했던 흐름을 다시 보자.
- 프로세스는 메모리(RAM)의 빈 공간에 할당된다.
- 최초 적합 전략 등을 활용하여 빈 공간에 프로세스들을 할당하게 되면 외부 단편화 문제가 발생한다.
- 외부 단편화 문제를 해결하기 위해 Paging 전략을 쓸 수 있다.
- 바로, 프로세스를 일정한 크기인 페이지(Page)로 잘라서 빈 공간에 넣는 전략이다.

  ![image](https://github.com/user-attachments/assets/986a07d8-b06a-4760-82e9-3edcae18f9c0)

- 페이징 전략을 쓰면 프로세스들이 잘라져서 흩어지게 되고, 나중에 분할된 프로세스들을 찾기 어려워 진다.
- 이를 해결하기 위해 분할된 페이지 주소를 테이블에 mapping 하는 메모리 매핑 전략도 함께 사용한다.
- 아래 그림과 같이 가상 메모리의 논리 주소를 물리 메모리의 물리 주소로 매핑하여 페이지 테이블에 저장한다.

  ![image](https://github.com/user-attachments/assets/41a02172-7276-42fa-8adb-c0b6ab558212)

- 해당 전략을 Android 에서도 사용하고 있으며, 페이징 전략에서 나타날 수 있는 내부 단편화 문제는 아래 나올 ZRAM이나 Low Memory Killer 등을 통해 해결하려 한다.

  
  [외부 단편화, 내부 단편화 문제 부가 설명](https://code-lab1.com/%EB%8B%A8%ED%8E%B8%ED%99%94/)

## 2. 여유 메모리를 확보하기 위한 Linux kernel 기능이 Android에 어떻게 적용되는가?
일반적으로 리눅스(Linux) 커널은 `Swapping` 과 `Killing` 매커니즘을 통해 메모리를 관리한다.


#### Swapping
 - 동작 방식: 메모리에 적재된 데이터를 디스크(스왑 공간)로 옮겨 RAM을 비운다.
 - Linux에서는 커널 스왑 데몬(이하 KSWAPD)이 애플리케이션이 사용 중인 메모리 영역(즉, 페이지)을 회수한다.
 - 새 할당을 위한 메모리 공간이 부족할 때 페이지를 익명 페이지, 버퍼, 덴트리, 아이노드, 프로세스 순서로 회수한다.
 - KSWAPD는 주기적으로 깨어나고, 사용 중인 메모리 공간의 양이 미리 정의된 임계값을 초과하면 메모리 공간 회수를 시작하게 된다.


이러한 KSWAPD의 노력에도 불구하고 사용 가능한 메모리 공간이 여전히 부족하면 `Killing`을 통해 종료해야 한다. 
#### Killing
 - 동작 방식: 메모리 부족 시 우선순위가 낮은 백그라운드 프로세스를 강제로 종료한다.
 - 커널은 불가피하게 피해 프로세스를 스캔하고, 해당 프로세스가 속한 전체 메모리 공간을 회수해야 한다.
 - 이를 실행하기 위해 해당 프로세스를 강제 종료하는 OOMK를 실행한다. `Out of Memory Killer` 

위는 Linux의 기본 기능에 대한 설명이었고, 안드로이드 플랫폼은 모바일 디바이스의 하드웨어 리소스가 제한되어 있다.


즉, 메모리 관리가 더 어려운 상황이므로, 리눅스 커널보다 더 많은 메모리 회수 단계를 채택하고 활용한다.
- 안드로이드 플랫폼에서 메모리 회수의 각 단계는 ZRAM, LMKD, OOMK의 순서로 트리거된다.
- 전통적인 Swap 방식은 I/O 비용 때문에 현재 잘 사용되지 않고, 위 3개의 방식이 주로 활용된다.

### (1) ZRAM (Compressed RAM)
- ZRAM은 RAM을 압축하여 사용 가능한 메모리 공간을 확장하는 기술이다.
- 일종의 swap 이지만, Disk I/O 를 일으키지 않고 일정 조건에 의해서 swap 할 메모리를 우선 압축하도록 한다.
- Android는 ZRAM을 사용하여 데이터를 디스크가 아닌 RAM 내에서 압축해 저장함으로써 성능을 향상시키고, 플래시 메모리의 수명을 절약한다.
- 이를 통해 메모리 부족 상황에서 성능 저하를 방지하고, 메모리 회수 속도를 높일 수 있다.


이는 Android 메모리 구조이다.
![image](https://github.com/user-attachments/assets/57a038ec-2441-461a-b084-f01a8be8025e)


메모리 부족 시 기존에 RAM에 있던 데이터를 압축하여 ZRAM으로 보내고, RAM의 효율성을 높일 수 있다. 
데이터를 ZRAM에 저장할 때는 압축되고, 다시 필요할 때는 압축이 해제되어서 RAM으로 반환되는 동작 흐름이다.

### (2) LMKD (Low Memory Killer Daemon)
- LMKD는 Android에서 메모리 부족 상태에 대응하는 프로세스이다.
- 시스템이 메모리가 부족할 경우, LMKD는 백그라운드 프로세스를 종료하여 메모리를 확보할 수 있다.
- 우선순위가 낮은 프로세스를 종료하여 시스템 성능을 유지하며, 사용자가 가장 중요한 작업을 실행할 때 방해받지 않도록 한다.
- Android에서는 LMKD가 기존 Linux Kernel의 OOMK를 확장하여 세밀하게 제어하며, 종료해야 할 프로세스를 선정한다.
---

ref.
- [Android 페이징과 메모리 매핑](https://everyday-develop-myself.tistory.com/281)
- [Linux의 Swapping과 OOMK 전략이 Android에 어떻게 반영되어 있는지](https://techblog.samsung.com/blog/article/5)
- [공식 문서: Android 프로세스 간 메모리 할당](https://developer.android.com/topic/performance/memory-management?hl=ko)

